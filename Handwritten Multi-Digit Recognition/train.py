# -*- coding: utf-8 -*-
"""trainer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lxXPoOVwtZ2sA86GZiSiypM7RX1B9cR7

# Import necessary libraries
"""

import numpy as np
from tensorflow.keras import layers     # For defining layers of the neural network
from tensorflow.keras import models     # For building the model architecture
from keras.datasets import mnist        # MNIST dataset of digits
from keras.utils import to_categorical  # Utility to convert labels to one-hot encoding

#Set a random seed for reproducibility

np.random.seed(42)

#load the mnist dataset from keras

(train_images, train_labels), (test_images, test_labels) = mnist.load_data()

#Preprocess the training data

train_images = train_images.reshape((60000, 28, 28, 1))

"""- We preprocess the training images before feeding them
to the model.

- Each image is 28x28 pixels, and there are 60,000 images in total.

- Originally, the images have the shape (60000, 28, 28) with no channel information.

- We reshape them to (60000, 28, 28, 1) to add the channel dimension.

- The extra dimension (1) represents the grayscale color channel, indicating the image has one color channel.

- This reshaping is necessary because models like Convolutional Neural Networks (CNNs) expect input data in a 4D format:
(batch size, height, width, channels).

- Without the channel dimension, CNNs cannot properly interpret the image data.
"""

#Normalize pixel values from range[0, 255] to [0, 1] for better performance during training

train_images = train_images.astype('float32') / 255

"""- Original pixel values range from 0 to 255 (because images use 8-bit color depth).

- Neural networks train better and faster when input values are small and consistent.

- Dividing by 255 scales all pixel values to the range 0 to 1.
"""

#Preprocess the test data

test_images = test_images.reshape((10000, 28, 28, 1))

test_images = test_images.astype('float32') / 255

#Convert class vectors (integers) to binary class matrices (one-hot encoding)

train_labels = to_categorical(train_labels)

test_labels = to_categorical(test_labels)

"""- The labels are originally integers representing classes

- One-hot encoding converts each integer into a binary vector where only the class index is 1 and the rest are 0.

![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAvAAAADFCAYAAAAyjsZNAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAACbrSURBVHhe7d0JkBRn/cbxdw2XrLCcyymwlCgGgUDAhIgQ5BYwIEkQiHJIWSQREAWLeOC/EkuJEDUxsaJRREmkKCSIiEgRRBEhCYZDBEXllPsSFkFO95/n3X7XYTK7Oz3zzuz27vdTNTUzvTPTM907bz/99q/fySkoKCgyAAAAACLhbcE1AAAAgAggwAMAAAARQoAHAAAAIoQADwAAAEQIAR4AAACIEAI8AAAAECEEeAAAACBCKjzAjxo1yjzyyCMmNzc3mJK8dJ5bnl69epnNmzebvXv3mpkzZwZTM8P3vLL53gEA1YO2J9quaPui7Uy6XnzxRbN//357DSCclAP8gw8+aFatWmV2795tv4D79u0z27dvNz/4wQ9Mt27dgkeV7cMf/rD58pe/bD73uc+ZL3zhC8HU5KTzXJ9cA7R27dpgCgBAfGwnMkHtdVnBMVvB0gVizSv+wjbFmKefftr+z2zdutX0798/mHqrX/ziF3Z56RqoTlIK8F//+tfNE088YTp16mTq1Klj/vOf/5jr16+bvLw886EPfch897vfNSNHjgweXbp//etf5t///re5evWqOXnyZDA1Oek8FwCQWb62E1EzcOBAs2zZMrNlyxZ7lDgZRUVF5vLly+bSpUslFy2v6k7BXcuhQYMG5q677gqm/o868lq3bm1u3rxpXn311WBqelJZf0BFCB3gZ8yYYRvdGjVqmD179phJkybZBrpjx47mG9/4hg3WzZo1Mw8//LDp0KFD8KzE9AXp06ePuf32280zzzwTTE1OOs8FAGSOz+1E1Lzvfe8zXbp0Me94xzuCKeVTeNcR5c6dO5dcquLOTVh/+MMfzIkTJ8xtt91munbtGkz9H4X6+vXrm/Pnz5vXXnstmJqeVNYfUBFCBfiCggIzYsQIU7t27ZL66o0bNwZ/Neb555833/nOd2xjpMey9woA1QvbCfhy4MAB88Ybb9gjFO985zvfUnevncK3ve1ttoRm/fr1wVSgeggV4O+8806Tn59vy1ZU1/j3v/89+Mv/LFq0yH6Z1PPy/ve/306bN29eSU3fV77yFfPnP//ZngQzZcqUhCdbqm5SX0a9vurffve739lem9iTZxKdqOnqCTVdJ7fqWs/X6/zsZz8r6elp3ry5WbBggXn99dft3/Te/vKXv5gf//jHGekNmjp1qnnllVfMX//6VzsvzVOfL1EPS82aNe370OfQe9+2bZv50pe+FPy12N13322WL19u37NeT6+7cuVKe0QCACqSj+2Ezm1S26c2UO3cCy+8cMtgBWqnf/jDH9ptiWtT1cZq25FJn/3sZ+3RX7fdiG979d6nTZtm23G936eeeuot27ewwiwXbdu++c1vljxGz9P5B1/84heDR5T/GZz47bC2py1atAj+eqvHHnvM9oDrcboodGtb796brnXfvS+9prbJ6lkvj8poVFLUuHFju+1zVBPftm1bc+PGDTs/Sfb/Qttk5Qq3DHStspny1p/m/9Of/vSWczriP2tsNtG2e82aNfZxWo+AT6ECvPaA1aui2vO//e1vwdS30j+u1KtXz147qmNTb0vdunWDKW81fvx4e1KqemauXbtm/vGPf9hDWerRSebLLjqkpgCvessjR47YPXSdMPX5z3/e/l1fsEGDBtnX0xdXF+ndu3fJY3zSZ1bDd+jQIdtYXrx40X4+NQrxJ3Ip1Pfo0cMcPnzYLmctMy2TWbNm2b/fe++9toG+4447zKlTp+zr6fChDvup3rQiTwwDgHS3E2orVXKjdu306dOmVq1att1zbbNCmk5u1DTNQ23gsWPHbJs6Z84cu61I1j333GODWPxF0+Op00clP9o50fvSdkO11yp3UZus+eq5arv/+9//2mCp4KbPqba6LC4sxr6H+MCXzHJReL3vvvvseQY6N0zLXztSLlwm8xnkgQcesKE8djusdZpoO6zXnDx5st2u6/X0WN1+6KGHSt7b3Llz7X29L71/fb73vve9Ccti4ikAHz9+3IZqbecclc9o+6jXU2dcsv8X8+fPtztC+j/VUSAtIy0Lveey1p/b9rqdCH1WLWO9h0984hN2/cUbMGCAec973mNycnKCKYA/KZ3EqmCsf/zSqEFIRHvQ+jKMHj3aNpDai433kY98xAZwhV194QcPHmyGDRtmH6sgngydMLVu3TrTt29fe/ntb39rv0D6Iqm2TTV13//+922Pg06C0Tx++ctf3vIYn37961+XfBbNTyd3afk1bdq0pPdJ1ECpsdVjdSLN/fffbxshNZy6r0ZYRy3U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)

"""

#Create a Sequential model – layers are added
#Creating the instance of the model

model = models.Sequential()

#Adding layers to the model
model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)))

"""- Convolutional Layer: This layer applies filters to the input image to detect features like edges, textures, and patterns.

- 32 filters: The layer uses 32 different filters (also called kernels), so it will learn 32 different features.

- Filter size (3x3): Each filter is a small 3 by 3 grid that slides over the image to scan it.

- ReLU activation: The activation function introduces non-linearity, helping the model learn complex patterns by converting negative values to zero and keeping positive values unchanged.

- input_shape=(28, 28, 1): This specifies the input size — 28 pixels wide, 28 pixels tall, with 1 color channel (grayscale).
"""

# MaxPooling layer:
model.add(layers.MaxPooling2D((2, 2)))

"""- Max pooling is a technique used in convolutional neural networks to reduce the size of feature maps (the outputs of convolution layers).
- It reduces the spatial dimensions (height and width) of the data, which lowers the computational load.
- Helps prevent overfitting by reducing the number of parameters the model needs to learn.
"""

# Dropout layer:

model.add(layers.Dropout(0.2))

"""- Dropout is a regularization technique used during neural network training to prevent overfitting.

- During each training step, it randomly sets a fraction of neurons’ outputs to zero (i.e., “drops” them out).
"""

# Second convolutional layer:

model.add(layers.Conv2D(64, (3, 3), activation='relu'))

"""- The layer uses 64 filters, each sized 3x3, to scan the input for features.

- It applies the ReLU activation function to add non-linearity and help the model learn complex patterns.
"""

# Another MaxPooling layer

model.add(layers.MaxPooling2D((2, 2)))

# Another Dropout layer (20%)

model.add(layers.Dropout(0.2))

# Third convolutional layer:

model.add(layers.Conv2D(64, (3, 3), activation='relu'))

"""- This layer applies 64 filters of size 3x3 to the input.

- Unlike previous layers, no pooling is applied, so the spatial size (height and width) stays the same, except reduced by convolution itself.
"""

# Flatten layer:

model.add(layers.Flatten())

"""- The Flatten layer takes the 3D output from the convolutional layers (height, width, channels).

- It reshapes this data into a 1D vector so it can be fed into dense layers, which expect 1D input.

- This step bridges the convolutional part of the network with the fully connected part.
"""

# Dense (fully connected) layer:
model.add(layers.Dense(64, activation='relu'))

"""It adds a dense (fully connected) layer to the model with:
- 64 units (neurons)
- ReLU activation function, which introduces non-linearity and helps the model learn complex features.
"""

# Output layer:

model.add(layers.Dense(10, activation='softmax'))

"""It adds the output layer with:

- 10 units, one for each digit class (0–9)

- Softmax activation, which turns the outputs into probabilities that sum to 1, helping the model choose the most likely class.
"""

# Print a summary of the model:
# Shows the number of parameters and the output shape of each layer

model.summary()

"""Summary of Architecture:
- 3 Convolutional layers – Extract visual features
- 2 MaxPooling layers – Reduce spatial dimensions
- 2 Dropout layers – Prevent overfitting
- 1 Flatten layer – Converts feature maps to a 1D vector
- 1 Dense (hidden) layer – Learns patterns from extracted features
- 1 Output layer (10 units) – Classifies digits (0–9) using softmax
"""

# Compile the model:

model.compile(optimizer='rmsprop',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

"""Compile the model with:
- optimizer='rmsprop' — adapts learning rate for better training (works well for CNNs and RNNs)
- loss='categorical_crossentropy' — measures error for multi-class problems with one-hot labels
- metrics=['accuracy'] — tracks accuracy to monitor model performance during training and validation
"""

# Fitting the model:

training_history = model.fit(train_images, train_labels, epochs=5, batch_size=64, validation_split=0.1)

"""Fitting the model:
- train_images and train_labels: input data and corresponding labels
- epochs=5: the model trains on the whole dataset 5 times  
- batch_size=64: weights update after every 64 samples
- validation_split=0.1: 10% of data used for validation to check performance on unseen data
"""

#Plot the model results upon Loss:

import matplotlib.pyplot as plt

# Set the x-axis and y-axis labels

plt.xlabel('Epoch Number') # X-axis will represent epochs
plt.ylabel('Loss')         # Y-axis will represent loss values

# Plot the training loss

plt.plot(training_history.history['loss'], label='Training Loss')

# Plot the validation loss

plt.plot(training_history.history['val_loss'], label='Validation Loss')

# Add a legend to label the two curves

plt.legend()

# Display the plot

plt.show()

# Plot the model results upon Accuracy:
 # Plot training and validation accuracy over epochs

plt.xlabel('Epoch Number')         # Label for x-axis (number of epochs)
plt.ylabel('Accuracy')             # Label for y-axis (accuracy values)

# Plot training accuracy
plt.plot(training_history.history['accuracy'], label='Training Accuracy')

# Plot validation accuracy
plt.plot(training_history.history['val_accuracy'], label='Validation Accuracy')

# Add legend to differentiate between the two curves
plt.legend()

# Display the plot
plt.show()

# Evaluate the model on the test data
# This computes the loss and accuracy of the model on the test set

test_loss, test_acc = model.evaluate(test_images, test_labels)

# Print the accuracy on the test set

print(f"Test Accuracy: {test_acc}")

# Save the trained model to a file (mnist.h5)
# This allows you to reload and use the model later without retraining

model.save('mnist.h5')

